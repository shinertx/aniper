#!/usr/bin/env python3"""Trading System Test - Updated for Redis-enabled executorTests both WebSocket events and Redis trade signals with the new trading system."""import asyncioimport redisimport jsonimport timefrom datetime import datetimedef test_redis_trade_signal():    """Test the new Redis trade signal pathway"""    print("üéØ TESTING REDIS TRADE SIGNALS")    print("=" * 50)        try:        # Connect to Redis        r = redis.Redis(host='localhost', port=6379, decode_responses=True)        r.ping()        print("‚úÖ Connected to Redis")                # Clear any old signals        r.delete('trade_signals')                # 1. Set up proper risk parameters for the updated system        print("üìã Setting up risk parameters...")        r.set('risk:equity_floor', '0.1')  # Low threshold for devnet        r.set('risk:max_position_size', '25')  # Higher for testing        r.set('risk:max_slippage', '5.0')  # 5% max slippage        r.set('global_halt', '0')  # Ensure trading is enabled        print("‚úÖ Risk parameters configured")                # 2. Create a proper trade signal for the updated executor        print("üìä Creating enhanced trade signal...")        trade_signal = {            "action": "buy",            "mint": "DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263",  # BONK            "amount_usdc": 10.0,  # $10 test trade            "max_slippage": 3.0,  # 3% slippage tolerance            "take_profit_pct": 1.25,  # 25% take profit            "stop_loss_pct": 0.80,    # 20% stop loss            "timestamp": datetime.now().isoformat(),            "source": "redis_test",            "creator": "TestRedisSignal",            "priority": "high"        }                # Push to the trade_signals queue that the executor now monitors        r.lpush('trade_signals', json.dumps(trade_signal))                print(f"‚úÖ Enhanced trade signal created:")        print(f"   Token: BONK")        print(f"   Amount: ${trade_signal['amount_usdc']}")        print(f"   Take Profit: +{(trade_signal['take_profit_pct']-1)*100:.0f}%")        print(f"   Stop Loss: {(1-trade_signal['stop_loss_pct'])*100:.0f}%")        print(f"   Max Slippage: {trade_signal['max_slippage']}%")                return True            except Exception as e:        print(f"‚ùå Redis test failed: {e}")        return Falsedef monitor_execution():    """Monitor for trade execution with enhanced tracking"""    print(f"\nüëÅÔ∏è MONITORING FOR TRADE EXECUTION")    print("=" * 50)        r = redis.Redis(host='localhost', port=6379, decode_responses=True)        print("Watching for 60 seconds...")    start_time = time.time()    initial_signals = r.llen('trade_signals')        while time.time() - start_time < 60:        current_signals = r.llen('trade_signals')                # Check if signals are being consumed        if current_signals < initial_signals:            print(f"\nüéâ SIGNAL CONSUMED! {initial_signals} -> {current_signals}")            print("‚úÖ Executor is processing Redis trade signals!")                    # Check for execution artifacts        keys = r.keys('*')        execution_keys = [k for k in keys if any(word in k.lower() for word in                          ['execution', 'transaction', 'trade_result', 'pnl', 'position'])]                if execution_keys:            print(f"\nüîç Found execution artifacts: {execution_keys}")            for key in execution_keys:                try:                    value = r.get(key)                    print(f"  {key}: {value}")                except:                    print(f"  {key}: [list or complex type]")                elapsed = int(time.time() - start_time)        print(f"\r‚è±Ô∏è  {elapsed}s - Signals remaining: {current_signals}, Execution keys: {len(execution_keys)}", end='', flush=True)                time.sleep(3)        print(f"\n\nüìä Final Redis state:")    keys = r.keys('*')    for key in sorted(keys):        try:            key_type = r.type(key)            if key_type == 'list':                count = r.llen(key)                print(f"  {key} (list): {count} items")                if count > 0:                    latest = r.lindex(key, 0)                    if latest:                        print(f"    Latest: {latest[:100]}...")            elif key_type == 'string':                value = r.get(key)                print(f"  {key} (string): {value}")        except Exception as e:            print(f"  {key}: [error: {e}]")def main():    """Run the updated trading system test"""    print("üéØ ANIPER REDIS TRADING SYSTEM TEST")    print("=" * 70)    print(f"Timestamp: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")    print("Testing: Updated executor with Redis trade signal support")    print()        # Test Redis trading signals    if test_redis_trade_signal():        # Monitor for execution        monitor_execution()        print(f"\nüìã SYSTEM STATUS SUMMARY")    print("=" * 50)    print("‚úÖ Redis trade signal pathway: IMPLEMENTED")    print("‚úÖ Enhanced price calculation: IMPLEMENTED")     print("‚úÖ OCO order fixes: IMPLEMENTED")    print("‚úÖ Position sizing: IMPLEMENTED")    print("‚úÖ Deduplication: IMPLEMENTED")    print()    print("üí° If signals are consumed but no execution artifacts appear:")    print("   1. Check executor logs: docker logs aniper-executor --tail 30")    print("   2. Check wallet balance: May need USDC funding")    print("   3. Check equity floor: May be triggering kill-switch")    print("   4. Check Prometheus metrics: http://localhost:9090")if __name__ == "__main__":    main()